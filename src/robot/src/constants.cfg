name = "Runtime constants";

motion = 
{
  limit_max_fraction  = 0.8;      // Only generate a trajectory to this fraction of max speed to give motors headroom to compensate
  controller_frequency  = 40 ;    // Hz for RobotController
  log_frequency         = 20 ;    // HZ for logging to motion log
  fake_perfect_motion   = true;   // Enable or disable bypassing clearcore to fake perfect motion for testing
  rate_always_ready     = false;   // Bypasses rate limiter if set to true
  translation = 
  {
    max_vel = 
    {
      fine   = 0.08; // m/s
      coarse = 0.2;  // m/s
    };
    max_acc = 
    {
      fine   = 0.1;  // m/s^2
      coarse = 0.5;  // m/s^2
    };
    max_jerk = 
    {
      fine   = 0.5;  // m/s^3
      coarse = 1.0;  // m/s^3
    };
    gains =
    {
      kp = 2.0;
      ki = 0.1;
      kd = 0.0;
    };
    gains_distance =
    {
      kp = 0.1;
      ki = 0.05;
      kd = 0.0;
    };
    distance_kf_cov = 0.1;
    position_threshold = 
    {
      fine = 0.01;   // m
      coarse = 0.10; // m
    };
    velocity_threshold = 
    {
      fine = 0.01;   // m/s
      coarse = 0.05; // m/s
    };
  };

  rotation = 
  {
    max_vel = 
    {
      fine   = 0.1;  // rad/s
      coarse = 0.4;  // rad/s
    };
    max_acc = 
    {
      fine   = 0.2;  // rad/s^2
      coarse = 1.0;  // rad/s^2
    };
    max_jerk = 
    {
      fine   = 0.5;  // rad/s^3
      coarse = 2.0;  // rad/s^3
    };
    gains =
    {
      kp = 3.0;
      ki = 0.1;
      kd = 0.0;
    };
    gains_distance =
    {
      kp = 2.0;
      ki = 0.1;
      kd = 0.0;
    };
    distance_kf_cov = 0.5;
    position_threshold = 
    {
      fine = 0.02;   // rad
      coarse = 0.08; // rad
    };
    velocity_threshold = 
    {
      fine = 0.01;   // rad/s
      coarse = 0.05; //rad/s
    };
  };
};

physical = 
{
  wheel_diameter = 0.152;  // m
  wheel_dist_from_center = 0.4794; // m
};

trajectory_generation = 
{
  solver_max_loops   = 30;     // Only let the solver loop this many times before giving up
  solver_alpha_decay = 0.8;    // Decay for velocity limit
  solver_beta_decay  = 0.8;    // Decay for acceleration limit
  solver_exponent_decay = 0.1; // Decay expoenent to apply each loop
  min_dist_limit    = 0.0001;  // Smallest value solver will attempt to solve for
};

tray = 
{
  default_pos_steps = 10;    // Default position for driving in steps from home
  load_pos_steps    = 5;     // Loading position in steps from home
  place_pos_steps   = 63;    // Placing position in steps from home
  controller_frequency  = 20 ;    // Hz for controller rate
  fake_tray_motions = false;   // Flag to fake tray motions for testing
};

localization = 
{
  update_fraction_at_zero_vel = 1.0;        // Controls the max a new marvelmind reading updates the position (at zero velocity)
  val_for_zero_update = 0.01;               // Normalized speeed values above this will not update the position from marvelmind. Note that this value is compared against the norm of the x,y,a velocity vector
  mm_x_offset = -55.0;                      // X offset of mm pair center from center of rotation (in millimeters, + is in front, - is behind)
  mm_y_offset = 0.0;                        // Y offset of mm pair center from center of rotation (in millimeters, + is to left, - is to right)
  position_reliability_buffer_size = 10;    // Number of previous positions to consider when checking if the current reading is valid
  position_reliability_zscore_thresh = 3.0; // Max number of standard deviations away from the previous positions to consider the reading valid
  position_reliability_max_stddev_pos = 0.05;   // Max stddev of last N position readings to consider the current reading valid to update current position 
  position_reliability_max_stddev_ang = 0.1;   // Max stddev of last N angle readings to consider the current reading valid to update current position 
  max_wait_time = 10.0;                     // Max time to wait (s) when waiting for good localization
  confidence_for_wait = 0.95;               // Confidence level required for waiting for localization 
  use_kf = true;                           // Whether to use kalman filter or not
  kf_trans_cov = 0.1;
  kf_angle_cov = 0.1;
};

distance_tracker =
{
  mapping =                                   
  {
    fwd_left = 0;                              // Which indices of the values recieved correspond to which sensor 
    fwd_right = 2;
    angled_left = 1;
    angled_right = 3;
  }
  dimensions = 
  {
    angle_from_fwd_degrees = -45.0;          // How many degrees from the x axis (signed) the angled sensors are turned
    left_fwd_offset = 0.2;                     // How many meters (signed) from the center of the robot the sensor is placed
    right_fwd_offset = -0.2;
    left_angle_offset = 0.16;
    right_angle_offset = -0.24;
  }
 num_sensors = 4;                              // Number of sensors total
 samples_to_average = 10;                      // How many readings to keep in the circular buffer for each sensor
};

mock_socket = 
{
  enabled = false;
  // Commands must have <> symbols and a number is to pause for that many ms
  data = ["<{'type':'init'}>", "20000","<{'type':'move_rel','data':{'x':1,'y':0,'a':0}}>","10000","<{'type':'place'}>","15000","<{'type':'move_rel','data':{'x':-1,'y':0,'a':0}}>"];
};
